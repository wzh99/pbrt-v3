#include "vcm.h"
#include "samplers/sobol.h"
#include "core/progressreporter.h"

namespace pbrt {

// Normally used in light path, camera vertices are represented by PathState
struct VCMIntegrator::Vertex {
    Point3f origin;
    Vector3f dir;
    Spectrum beta; // path throughput
    size_t pathLen = 0; // number of path segments, including this
    bool isFinite = true; // generated by finite light
    bool specular = true; // all scattering events so far are specular
    float dVC = 0, dVCM = 0;
};

struct VCMIntegrator::PathState {
    Spectrum beta; // path throughput, including emission
    size_t pathLen = 0; // the same as Vertex
    SurfaceInteraction isect;
    float dVC = 0, dVCM = 0;
};

VCMIntegrator::VCMIntegrator(std::shared_ptr<Camera> camera, int nIte, int maxDepth)
    : camera(camera), nIte(nIte), maxDepth(maxDepth) {}

#define MIS(x) ((x)*(x)) // use power heuristic

void pbrt::VCMIntegrator::Render(const pbrt::Scene& scene) {
    ProfilePhase _(Prof::IntegratorRender);

    // Initialize pixel bounds
    auto film = camera->film;
    const auto sampleBound = film->GetSampleBounds();
    const auto sampleExtent = sampleBound.Diagonal();
    nLightPaths = nPixels = sampleBound.Area();
    constexpr int tileSize = 16;
    const auto nXTiles = (sampleExtent.x + tileSize - 1) / tileSize;
    const auto nYTiles = (sampleExtent.y + tileSize - 1) / tileSize;

    // Initialize sampler
    SobolSampler globalSampler(nIte, sampleBound);

    // Initialize light distribution
    lightDistrib = ComputeLightPowerDistribution(scene);
    for (auto i = 0; i < scene.lights.size(); i++)
        lightIndex[scene.lights[i].get()] = i;

    // Main render loop
    ProgressReporter progress(nIte, "Rendering...");
    for (auto ite = 0; ite < nIte; ite++) {
        // Prepare memory arenas for all light tracing threads
        auto lightArenas = std::vector<MemoryArena>(MaxThreadIndex());

        // Trace light paths
        auto lightPaths = std::make_unique<Vertex * []>(nLightPaths);
        auto lightPathLengths = std::make_unique<size_t[]>(nLightPaths);
        constexpr auto chunkSize = 16;
        auto nChunk = (nLightPaths - 1) / chunkSize + 1;

        ParallelFor([&](int chunkIndex) {
            auto& arena = lightArenas[ThreadIndex];
            auto sampler = globalSampler.Clone(chunkIndex);
            for (auto i = 0; i < chunkSize; i++) {
                // Allocate space for light paths
                auto pathIndex = chunkIndex * chunkSize + i;
                if (pathIndex >= nPixels) return;
                sampler->StartPixel(Point2i(chunkIndex, i));
                sampler->SetSampleNumber(ite);
                lightPaths[pathIndex] = arena.Alloc<Vertex>(maxDepth);

                // Generate light sample and start random walk
                auto lightState = sampleLight(scene, *sampler);
                lightPathLengths[pathIndex] = lightRandomWalk(scene, *sampler, arena, lightState,
                    lightPaths[pathIndex], film);
            }
        }, nChunk);

        // Trace camera path
        ParallelFor2D([&](const Point2i tileIndex) {
            // Initialize tile sampling settings
            MemoryArena arena;
            auto seed = tileIndex.y * nXTiles + tileIndex.x;
            auto tileSampler = globalSampler.Clone(seed);

            // Get film tile
            auto x0 = sampleBound.pMin.x + tileIndex.x * tileSize;
            auto x1 = std::min(x0 + tileSize, sampleBound.pMax.x);
            auto y0 = sampleBound.pMin.y + tileIndex.y * tileSize;
            auto y1 = std::min(y0 + tileSize, sampleBound.pMax.y);
            Bounds2i tileBnd(Point2i(x0, y0), Point2i(x1, y1));
            auto filmTile = camera->film->GetFilmTile(tileBnd);

            for (auto pixelPos : tileBnd) {
                // Begin sampling for current pixel
                tileSampler->StartPixel(pixelPos);
                tileSampler->SetSampleNumber(ite);

                // Compute pixel offset
                auto pPixelO = Point2i(pixelPos - sampleBound.pMin);
                auto pixelOffset = pPixelO.x + pPixelO.y * (sampleBound.pMax.x - sampleBound.pMin.x);
            }

        }, Point2i(nXTiles, nYTiles)); // end parallel for loop

        progress.Update();
    } // end iteration loop

    // Finish render work
    film->WriteImage(1.0 / float(nIte));
    progress.Done();
}

}  // namespace pbrt
